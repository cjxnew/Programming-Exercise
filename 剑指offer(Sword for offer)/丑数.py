# 把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 
# 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。

'''
 方法：
 首先从丑数的定义我们知道，一个丑数的因子只有2,3,5，那么丑数p = 2^x * 3^y * 5^z，换句话说一个丑数
 一定由另一个丑数乘以2或者乘以3或者乘以5得到，那么我们从1开始乘以2,3,5，就得到2,3,5三个丑数，在从
 这三个丑数出发乘以2,3,5就得到4，6,10,6，9,15,10,15,25九个丑数，我们发现这种方法会得到重复的丑数，
 而且我们题目要求第N个丑数，这样的方法得到的丑数也是无序的。那么我们可以维护三个队列：
 （1）丑数数组： 1
 乘以2的队列：2
 乘以3的队列：3
 乘以5的队列：5
 选择三个队列头最小的数2加入丑数数组，同时将该最小的数乘以2,3,5放入三个队列；
 （2）丑数数组：1,2
 乘以2的队列：4
 乘以3的队列：3，6
 乘以5的队列：5，10
 选择三个队列头最小的数3加入丑数数组，同时将该最小的数乘以2,3,5放入三个队列；
 （3）丑数数组：1,2,3
 乘以2的队列：4,6
 乘以3的队列：6,9
 乘以5的队列：5,10,15
 选择三个队列头里最小的数4加入丑数数组，同时将该最小的数乘以2,3,5放入三个队列......
 实现思路：
 我们没有必要维护三个队列，只需要记录三个指针显示到达哪一步
 '''
 
 class Solution:
    def GetUglyNumber_Solution(self, index):
        # write code here
        if index <= 0:
            return 0
        uglys = []
        uglys.append(1)
        i2 = i3= i5 = 0
        while len(uglys) < index:
            minUgly = min(uglys[i2]*2, uglys[i3]*3, uglys[i5]*5)
            uglys.append(minUgly)
            if minUgly == uglys[i2]*2:
                i2 += 1
            if minUgly == uglys[i3]*3:
                i3 += 1
            if minUgly == uglys[i5]*5:
                i5 += 1
        return uglys[-1]
        
